function  Akima()
%задание узловых точек
tic
xi=[3.2 4.1 6.8 7.3 9.2 7.5 2.5]; 
%yi=[1 2.5 6.1 -1 -3];
yi=xi.^3+3.*(xi.^0.5+3)
% задаем точку или(набор точек дл€ подальшей интерпол€ции)
xx = dlmread('X.txt');
%на выходе получим значение(вектор значений)соотв. точкам хх 
%производим транспонирование векторов
xi = xi'; yi = yi';
%происходит сортировка узлов по возростанию 
[xi,I] = sort(xi); % в столбце I получаем номера позиций
%дл€ перестановки вектора у 
yi = yi(I); % переставили узлы на нужные позиции
n = length(xi); % узнали размерность
%производим расширение нашего вектора значений узловых точек, в
%соответствии  условием постороени€ сплайна јкимы
% производим прогнозирование поведение функции в последних n+1 u n+2 точках
% дл€ X
xi = [xi; xi(n)+diff(xi(n-2:n-1));xi(n)+diff(xi([n-2,n]))];
%¬ычисление матрицы коэф. дл€ прогнозировани€ значени€ ” в последующих точках
A = [[xi(n-2:n).^2]';[xi(n-2:n)]' ; 1 1 1];
%решение системы
B = yi(n-2:n)'/A;
% производим прогнозирование поведение функции в последних n+1 u n+2 точках
% дл€ ”
%¬ычисление значений полинома в "спрогнозированных" точках 
yi(n+1:n+2) = polyval(B,xi(n+1:n+2));
% прогнозируем ” в начальных точках X-1 u X-2
A = [[xi(1:3).^2]'; [xi(1:3)]' ; 1 1 1];
B = yi(1:3)'/A;
xi = [xi(1)-diff(xi([1 3])) ;xi(1)-diff(xi(2:3)); xi];
yi = [polyval(B,xi(1:2)); yi];

% ищем производные в узловых точках
h = diff(xi); % вычисление шага на каждом интервале
m = diff(yi)./h;

%построение вектора коэфициентов t
for i = 3:n+2;
  xnum = m(i-1)*abs(m(i+1)-m(i)) + m(i)*abs(m(i-1)-m(i-2));
  temp = abs(m(i+1)-m(i)) + abs(m(i-1)-m(i-2));
  t(i) = xnum / ( temp + ( temp == 0 ) ) .*(~(temp==0));
end
%%%%%%блок интерпол€ции в искомых узлах%%%%%%
% проходим циклом по всем полиномиальным интервалам и интерполируем наши
% значени€ в точках

figure('Color','w')
axes
% вывод данных маркерами
plot(xi,yi,'o')
hold on
plot(xi,yi,'--go');
for i= 1:n+2; 
  x_first = xi(i); x_next = xi(i+1);% x_first- первый элемент интервала
    %x_next - следующий элемент, после предыдущего
  bool = ( ( xx >= x_first ) & ( xx <= x_next ) ); % логическа€ 
  %переменна€ отвечающа€ 
  %за попадание "не узловой точки"
  %на тот или иой интервал содержащий данное значение
  if any(bool) % если ==1, то точка попала в данный интервал и производим 
    %расчет значени€ по формуле
    % считаем коэфф. дл€ интерпол€ционного многочлена
    C(4) = yi(i);
    C(3) = t(i);
    C(2) = (3*(yi(i+1)-yi(i))/h(i) - 2*t(i) - t(i+1))/h(i);
    C(1) = (t(i) + t(i+1) - 2*(yi(i+1)-yi(i))/h(i))/(h(i)^2);
    yy(bool) = C(4) +C(3)*(xx(bool)-xi(i))+C(2)*power(xx(bool)-xi(i),2)+C(1)*power(xx(bool)-xi(i),3);
  end
end
plot(xx,yy,'*');
grid on;
toc
end