function  res=Akima(xi,yi,XX,YY,func)
g=inline(func);
%задание узловых точек
tic
% задаем точку или(набор точек для подальшей интерполяции)
xx = dlmread('X.txt');
 %происходит сортировка по возростанию 
 xx = sort(xx); % в столбце I получаем номера позиций    
%на выходе получим значение(вектор значений)соотв. точкам хх 
%производим транспонирование векторов
xi = xi'; yi = yi';
n = length(xi); % узнали размерность
%производим расширение нашего вектора значений узловых точек, в
%соответствии  условием постороения сплайна Акимы
% производим прогнозирование поведение функции в последних n+1 u n+2 точках
% для X
xi = [xi; xi(n)+diff(xi(n-2:n-1));xi(n)+diff(xi([n-2,n]))];
%Вычисление матрицы коэф. для прогнозирования значения У в последующих точках
A = [[xi(n-2:n).^2]';[xi(n-2:n)]' ; 1 1 1];
%решение системы
B = yi(n-2:n)'/A;
% производим прогнозирование поведение функции в последних n+1 u n+2 точках
% для У
%Вычисление значений полинома в "спрогнозированных" точках 
yi(n+1:n+2) = polyval(B,xi(n+1:n+2));
% прогнозируем У в начальных точках X-1 u X-2
A = [[xi(1:3).^2]'; [xi(1:3)]' ; 1 1 1];
B = yi(1:3)'/A;
xi = [xi(1)-diff(xi([1 3])) ;xi(1)-diff(xi(2:3)); xi];
yi = [polyval(B,xi(1:2)); yi];

% ищем производные в узловых точках
h = diff(xi); % вычисление шага на каждом интервале
m = diff(yi)./h;

%построение вектора коэфициентов t
for i = 3:n+2;
  xnum = m(i-1)*abs(m(i+1)-m(i)) + m(i)*abs(m(i-1)-m(i-2));
  temp = abs(m(i+1)-m(i)) + abs(m(i-1)-m(i-2));
  t(i) = xnum / ( temp + ( temp == 0 ) ) .*(~(temp==0));
end
%%%%%%блок интерполяции в искомых узлах%%%%%%
% проходим циклом по всем полиномиальным интервалам и интерполируем наши
% значения в точках
yy = zeros(size(xx));

for i= 1:n+1; 
  x_first = xi(i); x_next = xi(i+1);% x_first- первый элемент интервала
    %x_next - следующий элемент, после предыдущего
  bool = ( ( xx >= x_first ) & ( xx <= x_next ) ); % логическая 
  %переменная отвечающая 
  %за попадание "не узловой точки" на определенный интервал
  %на тот или иой интервал содержащий данное значение
  if any(bool) % если ==1, то точка попала в данный интервал и производим 
    %расчет значения по формуле
    % считаем коэфф. для интерполяционного многочлена
    C(4) = yi(i);
    C(3) = t(i);
    C(2) = (3*(yi(i+1)-yi(i))/h(i) - 2*t(i) - t(i+1))/h(i);
    C(1) = (t(i) + t(i+1) - 2*(yi(i+1)-yi(i))/h(i))/(h(i)^2);
    yy(bool) = C(4) +C(3)*(xx(bool)-xi(i))+C(2)*power(xx(bool)-xi(i),2)+C(1)*power(xx(bool)-xi(i),3);
  end
end
for i=1:length(yy)
    error(i)=power((yy(i)-g(xx(i))),2);
end
Er=sum(error)/length(error);
subplot(2, 2, 2);
hold on;
plot_1=plot(xi(3:length(xi)-2),yi(3:length(xi)-2),'yo',XX,YY,':g',xx,yy,'r');
set(plot_1,'LineWidth', 5 ); 
title('График №2');
leg=legend('Узловые точки','Точное значение','Сплайн Акимы','Location','southeast');
xlabel('X');
ylabel('Y');
dlmwrite('Y_Akima.txt',yy);
grid on;
time=toc
res=[ time Er]
end